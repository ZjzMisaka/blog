## CAS操作
小鞠她为什么败北得那么惨, 就是因为没有使用CAS操作. 
为什么这么说呢, 这里涉及到CAS的概念. 我们尽可能一句话概括CAS操作:  CAS (Compare And Swap) 用于多线程环境下确保数据的一致性. 也就是将一个值与预期值作比较, 如果与预期值相同, 就将其更新为新值, 否则保持原样. 这一套操作是原子操作, 也就是说其他线程不会影响操作结果. 以CAS操作为代表的各种原子操作共同为无锁多线程编程创造了很多便利.  
回到正题, 我们先看看败北女角的其他女主. 比如我们的老八八奈见杏菜, 她在向袴田草介告白前确认了他对姬宫华恋的感情, 然后选择了放手. 又比如柠檬酱, 她甚至在告白之前就败北了, 根本没有确认的必要. 而小鞠就不一样了, 小鞠对慎太郎与月之木古都二人的关系始终抱着 "只不过是青梅竹马" 的自我安慰, 直到告白前始终没有进行确认, 最终结果就是如此.  
想象一下如果小鞠先进行比较慎太郎当前的状态是否是单身 "慎太郎君, 你现在有女朋友吗? " 在得到单身的答复后, 立刻对慎太郎进行状态更新, "我喜欢你, 和我交往吧! ". 从比较到告白的这段操作是CPU指令级别支持的一个单一的原子操作, 是不可分割的, 你可以理解为小鞠只用了一句话在一瞬间内完成了所有操作, 谁也插不了嘴. 这就是CAS操作与 "先检查后执行" 的根本区别, 它不会出现在确认单身状态后告白前的一小段时间内, 有别的偷腥猫借走慎太郎的控制权然后偷偷告白成功, 最终导致修罗场出现, 小鞠前功尽弃的情况.  
当然了这是理想中的情况, 实际上我们知道慎太郎已经在交往中了. 这种情况下小鞠就无法更新慎太郎的状态了, 她可以选择能够放下并寻找下一位有缘人或一边自我内耗一边等待慎太郎回心转意, 这里我们当然建议小鞠放下, 毕竟自我内耗太消耗CPU资源了. 但无论小鞠怎么选择, 至少也不至于在冒险告白后收获一大片 "完啦!!!" 的弹幕吧. 
综上所述, 使用CAS操作的主要用途是 "在确认状态后立刻更新状态, 不给其他人 (线程) 在这期间修改状态的机会". 妥善使用CAS操作, 至少能让你输得不那么惨. 如果不妥善使用CAS操作又不加锁, 就像诚哥一样, 刹那来了就更新状态, 西园寺来了又直接覆盖刹那的状态, 完全不进行锁定或者状态检查, 最终迎来无比悲惨的修罗场是必然的.  

## 无锁多线程编程的实际应用
现在假设一个类型AClass, AClass中包含一个用于CAS操作的标志变量, 它可能有三个值: 
```
1. 空闲状态
2. 被获取
3. 准备销毁
```
我们预计这个类的实例默认处于空闲状态, 对这个实例进行写入前将其设置被获取状态, 当这个实例没用了, 那就设置为准备销毁状态. 当这个实例被销毁了, 那这个实例就不存在了, 自然也不存在已销毁状态. 而对于这个实例的读取调用由于是线程安全的, 自然没必要为这种状态设置一个标志.  
无锁编程的一大技巧就是根据实例的状态进行灵活的跳过与等待. 这里先说跳过, 随后再说等待.  

### 跳过
在我们的程序中有一组AClass的实例, 我们计划不断创建, 读写, 调用这些实例. 那么如果我们要获取一个实例并写入怎么办? 这时候会用到CompareExchange (比较并更换) 的操作, 每个编程语言实现不同这里不作赘述, 我们关注它的作用: 比较一个标志是否是某个值, 并将这个标志设置为新的值.  
在这个例子中, 我们遍历我们程序中的AClass实例, 比较它是否处于 "1. 空闲状态", 并将其修改为 "2. 被获取状态". 这时候可能出现两个结果:  
1. 这个实例确实处于空闲状态且被设置为了被获取状态, 万事大吉.  
2. 这个实例现在不处于空闲状态因此设置失败.   

在第二种情况下, 如果我们使用lock (传统阻塞锁) 而不使用CAS操作, 我们会阻塞当前线程直到占用实例的其他线程写入完成. 但CAS操作给了我们更大的自由与灵活度, 我们可以直接不管这个实例, 诶我们去操作下一个实例, 我们没必要傻等着这个实例恢复自由身. 当然我们可以使用自旋等待 (后面会讲到) 来等待这个实例回到空闲状态, 但在这个例子中我们没有必要这么做.  

### 等待
首先简单说明一个概念: 自旋等待, 也就是不断地重复检查直到条件满足. 当然它与while (true)不断循环直到条件满足是不同的, 每个编程语言实现不同, 有些实现还会让出时间片, 这里不作赘述. 
假设我们现在判断一个实例是多余的, 要准备在它空闲时进行销毁, 怎么办? 这时候我们一定要销毁这一个特定的实例, 不可能说, 让其他实例躺枪, "来你替我死一死".  
我们分析一下, 首先我们一定是从要空闲状态将实例转换为准备销毁状态的, 因为如果它处于被获取状态, 说明它还有用, 不符合我们的预期.  
现在我们可以进行自旋等待, 它不同于lock阻塞锁, 它适合进行非常短时间等待, 否则占用很高的CPU使用率因此要谨慎使用, 这就是我们不建议小鞠放下而不是自我内耗等待慎太郎回心转意的原因, 不过在这个例子中自旋等待是适用的. 我们可以利用这个功能, 自旋等待直到CompareExchange (比较并更换) 的操作执行成功.  
在正常情况自旋等待完成后, 实例一定处于准备销毁状态, 如果自旋长时间进行无法结束, 说明我们的代码逻辑存在问题. 自旋完成后, 对于有些程序这时候可以放心销毁实例了, 但视情况也有些程序这时候还不能掉以轻心, 因为我们在进行自旋等待之前, 程序有可能已经完成了一次获取写入操作, 我们这时候可能还需要进行一次判断, 看看实例中是否存在未完成的任务, 或者新增加的资源, 这个视每个人的需求有不同的判断方式.  
现在由于这时候实例已经处于准备销毁状态, 这时候不会有其它线程对它进行写入, 所以这次判断结果是确定的, 如果这个实例确实没用了, 那就可以放心销毁了, 如果判断实例仍然有用, 可以再将其改回空闲状态.